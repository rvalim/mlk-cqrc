
# Internal Apps

## Bull Service Scheduler
The proposal of this document is to guide you through the structure used for Bull services, and help you to create and update Jobs.

### Technical References 

* [Bull](https://www.npmjs.com/package/bull)  - Redis based queue for Node, used to manage the schedule jobs
* [Bull Documentation](https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md) - A full documentation for the framework 
* [Bull Patterns](https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md) - Same examples of how it can be implemented
* [Arena]([https://www.npmjs.com/package/bull-arena]) - Using this application you can monitor the jobs created.
* [Redis](https://redis.io/) - A key valued pair database

### An overview of how Bull works

Bull register on Redis the keys with an specific name `<prefix>:<queue>:repeat:<jobId>:<timestamp>`.

 - `<prefix>`: By default is "bull", it is the basic way how the framework identify his own keys
 - `<queue>`:  The name for the Job's Queue
 - `repeat`:  This is a flag that mark a Job as a recurent Job 
 - `<jobID>`: A *Job* identifier generated by Bull, will be the same by its hole life
 - `<timestamp>`: This is how it schedule the jobs, the trigger time

So everytime a scheduled Job is executed, a new one will be registered on the Redis, under the same `<prefix>:<queue>:repeat:<jobId>` but with a new `timestamp`.

#### Bull's Dictionary

 - Queue: where we define Jobs
 - Job: The trigger, can be scheduled or repeatable
 - Worker: the code that process the Job. The Job is the trigger to the Worker
 - Events: A code that can be executed everytime a Job is triggered

### How Arena works
It is deployed by *docker-compose* by the name mlk-scheduler-arena. 

Once the Job is created will be listed on Arena (if the queue used is configured on Arena), for more information look at the Arena's documentation, here I will focus on how to put it to work.

In the solution folder you will see the structure below:
```
mlk-master
├── ...
├── config
├── ...					
|	├── bull-arena
|	|	└── index.json			# Where you configure the listen queues, in a array format, this json is copied to the container volume (specified on the docker-compose.yml)
|	└── ...
└── ...
```
The *index.json*, mentioned above, specifies to Arena what to listen. The structure is explained bellow, note that `queues` is an array, so you can specify more than one:
    
    {
		"queues": [
			{
				"name": "mlk-scheduler",	# The name of the Queue
				"hostId": "Queue Server 1",		# A name to be shown on Arena's screen
				"type": "Bull",					# Specify that we are monitoring Bull's log
				"prefix": "bull",				# The Redis's prefix for Bull's keys, this is the dafult value
				"host": "mlk-redis",		# Redis's host
				"port": 6379     				# Redis's port			
			}
		]
	}

### The basics

The code bellow is just an example, the production code is divided on `mlk-scheduler`, and other projects that specifies the workers according its business logic.

    const queue = new Queue(QUEUE_NAME, REDIS_AUTH);		# Creating/Connection to queue, the first parameter is the queue name, and the second configuration user and pass for Redis
    const jobName = 'job1';									# Job's Name
	const data = { quantity: 2 };							# An exemple of Job's data, note that it is fixed, because of this we have a REST service, to facilitate the changes without a new deploy
	const config = { repeat: { cron: '0 1 1 * *' } };		# All the possible configurations, in this case, a repeatable job, that will be executed every first day of each month
	const worker = async (job, done) => {					# This is code supposed to be executed by the Job
		...
		done();												# This callback, that can received parameters, is how you tell Bull that this job is completed
	}
	
	queue.add(jobName, data, config)						# Adding a Job to a queue, specifying its data and configuration

	queue.process(jobName, worker)							# Specifing how it will be process


### Folder Structure 

Because the data fixed information we divided the solution in two:

 - `mlk-scheduler`: Where you register you job with a REST API, the JobId will be registered on database, and will facilitates changing Job's data
 - Other projects, where you will specify your workers

**PS**: Job's name it is not a strong key, only jobId, I can have multiple jobs on the same queue, with the same name 

#### For mlk-scheduler 
```
..
├── ...
├── src		
├── ...					
|	├── bull
|	|	├── events
|	|	|	└── index.ts			# Made for a basic console.log for future customization, if it is necessary, note the "global:" prefix on logs, by default Bull only listen events on the same server, to listen all the servers we need this prefix 
|	├── frequency.ts				# Basic formatting for cron
|	├── index.ts					# Where the queue is started and the event listeners are defined
|	└── ...
├── ...
├── services
|	└── Handler
|	├── controller.ts				# This controller is used to create and update Bull's services. It is a contract to be follow, once you have Bull you can do everything you want, but updating service's data can be difficult, because you will need a new deploy for it. Using this REST service, you can register a new job, and update its data, this is the main purpose. 
|	└── ...
└── ...
```

#### Defining workers 
```
..
├── ...
├── src		
├── ...					
|	├── bull
|	|	├── worker
|	|	|	└── ...					# Made for a basic console.log for future customization, if it is necessary, note the "global:" prefix on logs, by default Bull only listen events on the same server, to listen all the servers we need this prefix 
|	├── index.ts					# Where we connect to the queue and start our workers. You have to use the same Queue and Job's name created on *mlk-scheduler*
|	└── ...
└── ...
```
**PS**: An example of Worker can be found on `mlk-profile`